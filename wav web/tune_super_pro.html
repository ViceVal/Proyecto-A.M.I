<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Tuner Super Pro — Detección Avanzada (Autocor + FFT)</title>
<style>
:root{
  --bg:#071018; --card:#0b1620; --accent:#00d084; --warn:#ff6b6b; --muted:#98aeb8;
}
html,body{height:100%;margin:0;background:linear-gradient(180deg,#071018,#041019);font-family:Inter, Arial, sans-serif;color:#e6eef6}
.container{max-width:980px;margin:26px auto;padding:18px}
.card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;padding:16px;box-shadow:0 10px 40px rgba(0,0,0,0.6)}
.header{display:flex;justify-content:space-between;align-items:center;gap:12px}
h1{margin:0;font-size:20px}
.lead{color:var(--muted);margin:0;font-size:13px}
.controls{display:flex;gap:8px;align-items:center}
button{background:#0d2632;border:1px solid rgba(255,255,255,0.03);color:#e6eef6;padding:10px 14px;border-radius:8px;cursor:pointer;font-weight:600}
button.secondary{background:transparent;border:1px solid rgba(255,255,255,0.06)}
button:disabled{opacity:.35;cursor:not-allowed}
.main{display:flex;gap:18px;margin-top:18px;flex-wrap:wrap}
.gauge{flex:1;min-width:360px;max-width:560px;padding:14px;border-radius:10px;background:rgba(255,255,255,0.01)}
#gcanvas{width:100%;height:260px;display:block}
.info{width:320px;min-width:260px;padding:14px;border-radius:10px;background:rgba(255,255,255,0.02)}
.big{font-size:46px;font-weight:800;letter-spacing:0.4px}
.sub{color:var(--muted);font-size:14px}
.cents{font-size:20px;font-weight:700}
.legend{display:flex;gap:10px;align-items:center;margin-top:10px}
.dot{width:10px;height:10px;border-radius:50%}
.dot.green{background:var(--accent)}.dot.gray{background:#7a8b95}
.row{display:flex;justify-content:space-between;align-items:center;margin-top:10px}
.range{width:100%}
.footer{margin-top:12px;color:var(--muted);font-size:13px}
.small{font-size:12px;color:var(--muted)}
.badge{display:inline-block;padding:6px 8px;border-radius:8px;background:rgba(255,255,255,0.02);font-weight:700}
.conf{margin-top:10px;font-weight:700}
@media (max-width:880px){.main{flex-direction:column}.info{width:100%}}
</style>
</head>
<body>
<div class="container">
  <div class="card">
    <div class="header">
      <div>
        <h1>Tuner Super Pro</h1>
        <p class="lead">Autocorrelación + FFT · Estabilidad · Detecta cuerda · Zona perfecta</p>
      </div>

      <div class="controls">
        <button id="startBtn">Iniciar Afinador</button>
        <button id="stopBtn" class="secondary" disabled>Detener</button>
      </div>
    </div>

    <div class="main">
      <div class="gauge">
        <canvas id="gcanvas" width="560" height="260"></canvas>
        <div style="display:flex;justify-content:space-between;margin-top:8px">
          <span class="small">Grave</span>
          <span class="small">Agudo</span>
        </div>
      </div>

      <div class="info">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div>
            <div id="noteName" class="big">—</div>
            <div id="noteLatin" class="sub">—</div>
          </div>
          <div style="text-align:right">
            <div id="cents" class="cents">—</div>
            <div id="targetFreq" class="sub">— Hz</div>
          </div>
        </div>

        <div class="row">
          <div>
            <div class="small">Cuerda detectada</div>
            <div id="stringDetected" class="badge">—</div>
          </div>

          <div>
            <div class="small">Confianza</div>
            <div id="confidence" class="badge">—</div>
          </div>
        </div>

        <div style="margin-top:12px">
          <label class="small">Sensibilidad (RMS umbral)</label>
          <input id="sensitivity" class="range" type="range" min="0.001" max="0.05" step="0.001" value="0.01">
        </div>

        <div style="margin-top:8px">
          <label class="small">Tolerancia (cents para "afinado") <span id="tolVal">5</span>c</label>
          <input id="tolerance" class="range" type="range" min="1" max="20" step="1" value="5">
        </div>

        <div style="margin-top:10px" class="legend">
          <div style="display:flex;gap:8px;align-items:center"><div class="dot green"></div> Zona perfecta</div>
          <div style="display:flex;gap:8px;align-items:center"><div class="dot gray"></div> Rango ±50c</div>
        </div>

        <div class="conf" id="status">Estado: —</div>
        <div class="footer">Presiona Iniciar y permite el acceso al micrófono. Usa una cuerda aislada para mejores resultados.</div>
      </div>
    </div>
  </div>
</div>

<script>
/* ---------------------
   Config - notas / cuerdas
   --------------------- */
const NOTES = {"C":261.63,"C#":277.18,"D":293.66,"D#":311.13,"E":329.63,"F":349.23,"F#":369.99,"G":392.00,"G#":415.30,"A":440.00,"A#":466.16,"B":493.88};
// We'll use target guitar strings by frequency (standard EADGBE tuned to E2..E4 as earlier)
const STRINGS = { "E2":82.41,"A2":110.00,"D3":146.83,"G3":196.00,"B3":246.94,"E4":329.63 };
const STRINGS_ORDER = ["E2","A2","D3","G3","B3","E4"];
const NOTAS_LATINAS = {"C":"Do","C#":"Do#","D":"Re","D#":"Re#","E":"Mi","F":"Fa","F#":"Fa#","G":"Sol","G#":"Sol#","A":"La","A#":"La#","B":"Si"};

/* ---------------------
   UI elements
   --------------------- */
const startBtn = document.getElementById('startBtn');
const stopBtn = document.getElementById('stopBtn');
const canvas = document.getElementById('gcanvas');
const ctx = canvas.getContext('2d');

const noteNameEl = document.getElementById('noteName');
const noteLatinEl = document.getElementById('noteLatin');
const centsEl = document.getElementById('cents');
const targetFreqEl = document.getElementById('targetFreq');
const stringDetectedEl = document.getElementById('stringDetected');
const confidenceEl = document.getElementById('confidence');
const statusEl = document.getElementById('status');

const sensRange = document.getElementById('sensitivity');
const tolRange = document.getElementById('tolerance');
const tolVal = document.getElementById('tolVal');
tolRange.addEventListener('input', ()=> tolVal.textContent = tolRange.value);

/* ---------------------
   Audio / analyser
   --------------------- */
let audioCtx = null;
let analyser = null;
let mediaStream = null;
let fftSize = 16384; // high resolution FFT
let timeDomain = null;
let freqDomain = null;

/* ---------------------
   State & stability
   --------------------- */
let historyFreq = []; // circular small buffer
const HISTORY_MAX = 6; // number of frames to smooth
let lastDetected = { freq:0, note:'—', cents:0, string:'—', conf:0 };

/* ---------------------
   Helpers
   --------------------- */
function map(v,a,b,c,d){ return (v-a)*(d-c)/(b-a)+c; }
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function toCents(freq, target){ return 1200 * Math.log2(freq/target); }

/* quadratic interpolation for peak refinement
   given arrays of magnitude in dB (or linear), and index of peak
*/
function parabolicPeakInterp(magArr, index){
  const alpha = magArr[index-1] || -Infinity;
  const beta  = magArr[index];
  const gamma = magArr[index+1] || -Infinity;
  // convert from dB if necessary; we use linear magnitudes, but interpolation formula same
  const p = 0.5 * (alpha - gamma) / (alpha - 2*beta + gamma);
  return index + p;
}

/* find peak in frequency domain with quadratic interpolation */
function peakFromFFT(freqData, sampleRate, fftSize){
  // freqData is Float32Array from analyser.getFloatFrequencyData (dB) or getByteFrequencyData
  // But we'll use getFloatFrequencyData for dB. Convert to linear magnitude.
  let bestIdx = 0;
  let bestVal = -Infinity;
  // search within human-guitar band (50Hz..1400Hz) to avoid low hum and high noise
  const binFreq = sampleRate / fftSize;
  const startBin = Math.max(2, Math.floor(50 / binFreq));
  const endBin   = Math.min(freqData.length-2, Math.ceil(1400 / binFreq));
  for(let i=startBin;i<=endBin;i++){
    const val = freqData[i]; // in dB (negative numbers, larger = closer to 0)
    if (val > bestVal){ bestVal = val; bestIdx = i; }
  }
  // Build a small linear array around bestIdx (convert dB to linear)
  const linear = [];
  for(let k = bestIdx-2; k <= bestIdx+2; k++){
    const v = freqData[k];
    linear.push(Math.pow(10, v/20)); // dB -> linear
  }
  const interpIndex = parabolicPeakInterp(linear, 2); // center at index 2 of this small array
  // map back to global index:
  const globalIndex = bestIdx + (interpIndex - 2);
  const freq = globalIndex * binFreq;
  // approximate magnitude:
  const magnitudeLinear = Math.pow(10, bestVal/20);
  return {freq, magnitude: magnitudeLinear, bin:globalIndex};
}

/* autocorrelation pitch detection (fast) -> returns freq or -1 */
function autoCorrelate(buf, sampleRate){
  const SIZE = buf.length;
  let rms = 0;
  for(let i=0;i<SIZE;i++){ const v = buf[i]; rms += v*v; }
  rms = Math.sqrt(rms/SIZE);
  if (rms < parseFloat(sensRange.value)) return -1;

  let r = new Float32Array(SIZE);
  for(let lag=0; lag<SIZE; lag++){
    let sum = 0;
    for(let i=0;i<SIZE-lag;i++) sum += buf[i]*buf[i+lag];
    r[lag] = sum;
  }
  let peak = 1;
  for(let i=2;i<SIZE;i++){
    if (r[i] > r[peak]) peak = i;
  }
  if (peak === 0) return -1;
  // refine with parabolic interpolation around peak
  const left = r[peak-1], center = r[peak], right = r[peak+1] || 0;
  const shift = 0.5 * (left - right) / (left - 2*center + right);
  const trueLag = peak + shift;
  const freq = sampleRate / trueLag;
  if (!isFinite(freq) || freq <= 0) return -1;
  return freq;
}

/* find closest string from STRINGS */
function closestString(freq){
  let best = null, minDiff=Infinity;
  for(const s of STRINGS_ORDER){
    const f = STRINGS[s];
    const d = Math.abs(Math.log2(freq/f));
    if (d < minDiff){ minDiff = d; best = s; }
  }
  return best;
}

/* find closest note (A4=440 base table dynamic across octaves) */
function freqToNote(freq){
  // We'll map frequency to nearest note name (A4=440 reference)
  const A4 = 440;
  const semitone = 12 * Math.log2(freq / A4);
  const midi = Math.round(semitone) + 69;
  const noteIndex = (midi + 120) % 12;
  const names = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
  const octave = Math.floor(midi / 12) - 1;
  const name = names[noteIndex] + octave;
  // compute exact freq of that midi:
  const exactFreq = A4 * Math.pow(2, (midi - 69)/12);
  return {name, exactFreq};
}

/* combine methods: prefer autocorr for low freq stability, use FFT for magnitude/confirm */
function combinedPitchDetection(timeBuf, sampleRate, freqData){
  // autocorr
  const ac = autoCorrelate(timeBuf, sampleRate);
  // fft peak
  const fftPeak = peakFromFFT(freqData, sampleRate, analyser.fftSize);
  // if autocorr valid and within band, prefer it; else use fft
  if (ac > 50 && ac < 1200){
    // if FFT frequency close to autocorr within 6% -> average for stability
    if (fftPeak.freq > 0 && Math.abs(fftPeak.freq - ac)/ac < 0.06){
      return {freq: (ac + fftPeak.freq)/2, mag: fftPeak.magnitude, method:'both'};
    } else {
      return {freq: ac, mag: fftPeak.magnitude, method:'autocorr'};
    }
  } else {
    return {freq: fftPeak.freq, mag: fftPeak.magnitude, method:'fft'};
  }
}

/* ---------------------
   Drawing gauge
   --------------------- */
function drawGauge(cents, tolerance, conf){
  const W = canvas.width, H = canvas.height;
  ctx.clearRect(0,0,W,H);

  // arc parameters
  const cx = W/2, cy = H*1.15, r = Math.min(W*0.45, H*1.6);

  // base arc
  ctx.lineWidth = 2;
  ctx.strokeStyle = "rgba(255,255,255,0.06)";
  ctx.beginPath();
  ctx.arc(cx, cy, r, Math.PI*1.05, Math.PI*-0.05, false);
  ctx.stroke();

  // ticks
  ctx.strokeStyle = "rgba(255,255,255,0.06)";
  for(let c=-50;c<=50;c+=5){
    const ang = map(c, -50, 50, Math.PI*1.05, Math.PI*-0.05);
    const x1 = cx + Math.cos(ang)*(r*0.92);
    const y1 = cy + Math.sin(ang)*(r*0.92);
    const x2 = cx + Math.cos(ang)*(r*0.98);
    const y2 = cy + Math.sin(ang)*(r*0.98);
    ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
  }

  // small sweet spot ± (tolerance limited to small)
  const small = Math.min(6, Math.max(1, parseInt(tolerance))); // make it small-ish
  const leftAng = map(-small, -50, 50, Math.PI*1.05, Math.PI*-0.05);
  const rightAng = map(small, -50, 50, Math.PI*1.05, Math.PI*-0.05);

  ctx.beginPath();
  ctx.fillStyle = "rgba(0,208,132,0.22)";
  ctx.moveTo(cx,cy);
  ctx.arc(cx,cy,r*0.86, rightAng, leftAng, true);
  ctx.closePath();
  ctx.fill();

  // needle
  const ang = map(cents, -50, 50, Math.PI*1.05, Math.PI*-0.05);
  const nx = cx + Math.cos(ang)*(r*0.78);
  const ny = cy + Math.sin(ang)*(r*0.78);

  // shadow
  ctx.beginPath(); ctx.strokeStyle = "rgba(0,0,0,0.45)"; ctx.lineWidth = 6; ctx.moveTo(cx,cy); ctx.lineTo(nx,ny); ctx.stroke();
  // needle
  ctx.beginPath(); ctx.strokeStyle = (Math.abs(cents) <= tolerance ? "rgba(0,208,132,0.98)" : "rgba(255,107,107,0.98)"); ctx.lineWidth = 3; ctx.moveTo(cx,cy); ctx.lineTo(nx,ny); ctx.stroke();

  // center cap
  ctx.beginPath(); ctx.fillStyle = "#cbd6dc"; ctx.arc(cx,cy,6,0,Math.PI*2); ctx.fill();

  // left/right labels
  ctx.fillStyle = "rgba(230,238,246,0.9)"; ctx.font = "12px system-ui"; ctx.textAlign="left"; ctx.fillText("Grave", 10, 18); ctx.textAlign="right"; ctx.fillText("Agudo", W-10, 18);

  // confidence bar
  const barW = 160, barH = 10;
  const bx = W - barW - 12, by = 12;
  ctx.fillStyle = "rgba(255,255,255,0.06)"; ctx.fillRect(bx, by, barW, barH);
  ctx.fillStyle = "rgba(0,208,132,0.9)"; ctx.fillRect(bx, by, barW * clamp(conf,0,1), barH);
  ctx.strokeStyle = "rgba(255,255,255,0.08)"; ctx.strokeRect(bx, by, barW, barH);
  ctx.textAlign="center"; ctx.fillStyle="#bfead1"; ctx.font="11px system-ui"; ctx.fillText("Confianza", bx+barW/2, by + barH + 11);
}

/* ---------------------
   Main update loop: read analyser, detect pitch, smooth, update UI
   --------------------- */
function processFrame(){
  if (!analyser) return;

  // read time domain and freq domain
  analyser.getFloatTimeDomainData(timeDomain);
  analyser.getFloatFrequencyData(freqDomain); // dB values

  // detection
  const detection = combinedPitchDetection(timeDomain, audioCtx.sampleRate, freqDomain);
  let freq = detection.freq;
  if (!isFinite(freq) || freq <= 0) {
    statusEl.textContent = 'Estado: sin señal válida';
    drawGauge(0, parseInt(tolRange.value), 0);
    requestAnimationFrame(processFrame);
    return;
  }

  // push into history and compute stable median
  historyFreq.push(freq);
  if (historyFreq.length > HISTORY_MAX) historyFreq.shift();
  // median for stability
  const sorted = [...historyFreq].sort((a,b)=>a-b);
  const median = sorted[Math.floor(sorted.length/2)];

  // confidence: use magnitude + closeness between methods + history variance
  let mag = detection.mag || 0;
  // map mag (linear) to 0..1 roughly (tuned empirically)
  let magScore = clamp((mag*8), 0, 1); // mag typically small
  // method bonus: if combined used both, boost confidence
  let methodBonus = (detection.method==='both')?0.15:0.0;
  // history variance penalty
  const mean = historyFreq.reduce((a,b)=>a+b,0)/historyFreq.length;
  const variance = historyFreq.reduce((s,v)=>s+(v-mean)*(v-mean),0)/historyFreq.length;
  const stabScore = clamp(1 - Math.sqrt(variance)/20, 0, 1); // more variance -> lower
  let conf = clamp(0.25*magScore + 0.6*stabScore + methodBonus, 0, 1);

  // choose displayed frequency from median (more stable)
  const displayFreq = median;

  // map to note + cents
  const noteObj = freqToNote(displayFreq);
  const noteName = noteObj.name;
  const exactFreq = noteObj.exactFreq;
  const cents = toCents(displayFreq, exactFreq);

  // string detection (closest string by log-distance)
  const stringName = closestString(displayFreq);

  // update UI
  noteNameEl.textContent = noteName;
  const base = noteName.replace(/[0-9]/g, '').replace('#','♯');
  noteLatinEl.textContent = (NOTAS_LATINAS[base.replace('♯','#')] || base) + '  —  ' + (detection.method||'');
  centsEl.textContent = `${cents>=0?'+':''}${cents.toFixed(1)} c`;
  targetFreqEl.textContent = `${exactFreq.toFixed(2)} Hz`;
  stringDetectedEl.textContent = stringName;
  confidenceEl.textContent = `${Math.round(conf*100)}%`;
  statusEl.textContent = `Método: ${detection.method} · RMS umbral ${parseFloat(sensRange.value).toFixed(3)}`;

  // draw gauge
  drawGauge(clamp(cents,-50,50), parseInt(tolRange.value), conf);

  // keep lastDetected
  lastDetected = { freq:displayFreq, note:noteName, cents, string:stringName, conf };

  requestAnimationFrame(processFrame);
}

/* ---------------------
   Start / stop microphone
   --------------------- */
startBtn.addEventListener('click', async ()=>{
  try {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const stream = await navigator.mediaDevices.getUserMedia({ audio:true });
    mediaStream = stream;
    const src = audioCtx.createMediaStreamSource(stream);

    analyser = audioCtx.createAnalyser();
    analyser.fftSize = fftSize;
    timeDomain = new Float32Array(analyser.fftSize);
    freqDomain = new Float32Array(analyser.frequencyBinCount);

    // connect
    src.connect(analyser);

    startBtn.disabled = true;
    stopBtn.disabled = false;

    // reset history
    historyFreq = [];

    // start loop
    requestAnimationFrame(processFrame);
    statusEl.textContent = 'Estado: escuchando...';
  } catch (e) {
    console.error(e);
    alert('No se pudo acceder al micrófono. Revisa permisos.');
  }
});

stopBtn.addEventListener('click', ()=>{
  if (mediaStream){
    mediaStream.getTracks().forEach(t=>t.stop());
    mediaStream = null;
  }
  if (audioCtx){
    audioCtx.close();
    audioCtx = null;
  }
  analyser = null;
  startBtn.disabled = false;
  stopBtn.disabled = true;
  statusEl.textContent = 'Estado: detenido';
});

/* ---------------------
   Inicial draw
   --------------------- */
drawGauge(0, parseInt(tolRange.value), 0);
</script>
</body>
</html>
