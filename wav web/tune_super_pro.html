<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Tuner Super Pro — YIN + Autocorr (Mejorado)</title>
<style>
:root{
  --bg:#071018; --card:#0b1620; --accent:#00d084; --warn:#ff6b6b; --muted:#98aeb8;
}
html,body{height:100%;margin:0;background:linear-gradient(180deg,#071018,#041019);font-family:Inter, Arial, sans-serif;color:#e6eef6}
.container{max-width:980px;margin:26px auto;padding:18px}
.card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;padding:16px;box-shadow:0 10px 40px rgba(0,0,0,0.6)}
.header{display:flex;justify-content:space-between;align-items:center;gap:12px}
h1{margin:0;font-size:20px}
.lead{color:var(--muted);margin:0;font-size:13px}
.controls{display:flex;gap:8px;align-items:center}
button{background:#0d2632;border:1px solid rgba(255,255,255,0.03);color:#e6eef6;padding:10px 14px;border-radius:8px;cursor:pointer;font-weight:600}
button.secondary{background:transparent;border:1px solid rgba(255,255,255,0.06)}
button:disabled{opacity:.35;cursor:not-allowed}
.main{display:flex;gap:18px;margin-top:18px;flex-wrap:wrap}
.gauge{flex:1;min-width:360px;max-width:560px;padding:14px;border-radius:10px;background:rgba(255,255,255,0.01)}
#gcanvas{width:100%;height:260px;display:block}
.info{width:320px;min-width:260px;padding:14px;border-radius:10px;background:rgba(255,255,255,0.02)}
.big{font-size:46px;font-weight:800;letter-spacing:0.4px}
.sub{color:var(--muted);font-size:14px}
.cents{font-size:20px;font-weight:700}
.legend{display:flex;gap:10px;align-items:center;margin-top:10px}
.dot{width:10px;height:10px;border-radius:50%}
.dot.green{background:var(--accent)}.dot.gray{background:#7a8b95}
.row{display:flex;justify-content:space-between;align-items:center;margin-top:10px}
.range{width:100%}
.footer{margin-top:12px;color:var(--muted);font-size:13px}
.small{font-size:12px;color:var(--muted)}
.badge{display:inline-block;padding:6px 8px;border-radius:8px;background:rgba(255,255,255,0.02);font-weight:700}
.conf{margin-top:10px;font-weight:700}
input[type=range]{width:100%}
@media (max-width:880px){.main{flex-direction:column}.info{width:100%}}
</style>
</head>
<body>
<div class="container">
  <div class="card">
    <div class="header">
      <div>
        <h1>Tuner Super Pro — YIN + Autocorr</h1>
        <p class="lead">Detección robusta de pitch para guitarra — mejor precisión con micrófono</p>
      </div>

      <div class="controls">
        <button id="startBtn">Iniciar Afinador</button>
        <button id="stopBtn" class="secondary" disabled>Detener</button>
      </div>
    </div>

    <div class="main">
      <div class="gauge">
        <canvas id="gcanvas" width="560" height="260"></canvas>
        <div style="display:flex;justify-content:space-between;margin-top:8px">
          <span class="small">Grave</span>
          <span class="small">Agudo</span>
        </div>
      </div>

      <div class="info">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div>
            <div id="noteName" class="big">—</div>
            <div id="noteLatin" class="sub">—</div>
          </div>
          <div style="text-align:right">
            <div id="cents" class="cents">—</div>
            <div id="targetFreq" class="sub">— Hz</div>
          </div>
        </div>

        <div class="row">
          <div>
            <div class="small">Cuerda detectada</div>
            <div id="stringDetected" class="badge">—</div>
          </div>

          <div>
            <div class="small">Confianza</div>
            <div id="confidence" class="badge">—</div>
          </div>
        </div>

        <div style="margin-top:12px">
          <label class="small">Sensibilidad (RMS umbral)</label>
          <input id="sensitivity" class="range" type="range" min="0.001" max="0.05" step="0.001" value="0.01">
        </div>

        <div style="margin-top:8px">
          <label class="small">Tolerancia (cents para "afinado") <span id="tolVal">5</span>c</label>
          <input id="tolerance" class="range" type="range" min="1" max="20" step="1" value="5">
        </div>

        <div style="margin-top:10px" class="legend">
          <div style="display:flex;gap:8px;align-items:center"><div class="dot green"></div> Zona perfecta</div>
          <div style="display:flex;gap:8px;align-items:center"><div class="dot gray"></div> Rango ±50c</div>
        </div>

        <div class="conf" id="status">Estado: —</div>
        <div class="footer">Consejo: usa una cuerda aislada y acércala al micrófono para mejor precisión.</div>
      </div>
    </div>
  </div>
</div>

<script>
/* ======================
   Config notas y cuerdas
   ====================== */
const NOTAS_LATINAS = {"C":"Do","C#":"Do#","D":"Re","D#":"Re#","E":"Mi","F":"Fa","F#":"Fa#","G":"Sol","G#":"Sol#","A":"La","A#":"La#","B":"Si"};
const STRINGS = { "E2":82.41,"A2":110.00,"D3":146.83,"G3":196.00,"B3":246.94,"E4":329.63 };
const STRINGS_ORDER = ["E2","A2","D3","G3","B3","E4"];

/* ======================
   UI elements
   ====================== */
const startBtn = document.getElementById('startBtn');
const stopBtn = document.getElementById('stopBtn');
const canvas = document.getElementById('gcanvas');
const ctx = canvas.getContext('2d');

const noteNameEl = document.getElementById('noteName');
const noteLatinEl = document.getElementById('noteLatin');
const centsEl = document.getElementById('cents');
const targetFreqEl = document.getElementById('targetFreq');
const stringDetectedEl = document.getElementById('stringDetected');
const confidenceEl = document.getElementById('confidence');
const statusEl = document.getElementById('status');

const sensRange = document.getElementById('sensitivity');
const tolRange = document.getElementById('tolerance');
const tolVal = document.getElementById('tolVal');
tolRange.addEventListener('input', ()=> tolVal.textContent = tolRange.value);

/* ======================
   Audio / analyser
   ====================== */
let audioCtx = null;
let mediaStream = null;
let analyser = null;
let timeBuf = null;
let freqBuf = null;
let FFT_SIZE = 4096; // ventana recomendada (4096)
let HISTORY_MAX = 6;

/* ======================
   Estado y suavizado
   ====================== */
let history = []; // buffer de frecuencias recientes
let lastStableFreq = 0;
let stabilityCount = 0;
let smoothingAlpha = 0.75; // exponencial smoothing (0..1)
let lastSmoothed = 0;

/* ======================
   Helpers
   ====================== */
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
function map(v,a,b,c,d){ return (v-a)*(d-c)/(b-a)+c; }
function toCents(freq,target){ return 1200*Math.log2(freq/target); }

function freqToNote(freq){
  if (!isFinite(freq) || freq<=0) return {name:'—', exactFreq:0};
  const A4 = 440;
  const semitone = 12 * Math.log2(freq / A4);
  const midi = Math.round(semitone) + 69;
  const noteIndex = (midi + 120) % 12;
  const names = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
  const octave = Math.floor(midi / 12) - 1;
  const name = names[noteIndex] + octave;
  const exactFreq = A4 * Math.pow(2, (midi - 69)/12);
  return {name, exactFreq};
}

function closestString(freq){
  let best=null, minDiff=Infinity;
  for(const s of STRINGS_ORDER){
    const f = STRINGS[s];
    const d = Math.abs(Math.log2(freq/f));
    if (d < minDiff){ minDiff = d; best = s; }
  }
  return best;
}

/* ======================
   YIN pitch detection (optimized)
   ====================== */
function detectPitchYIN(buf, sampleRate) {
  // buf: Float32Array time domain, length >= maxTau*2 ideally
  // We'll search fundamental between 60Hz and 1200Hz (guitar safe)
  const maxFreq = 1200;
  const minFreq = 60;
  const maxTau = Math.floor(sampleRate / minFreq); // lag max
  const minTau = Math.floor(sampleRate / maxFreq); // lag min

  const yinBuffer = new Float32Array(maxTau+1);
  let runningSum = 0;

  // difference function
  for (let tau = 1; tau <= maxTau; tau++) {
    let sum = 0;
    // limit i to avoid overflow
    const limit = buf.length - tau;
    for (let i = 0; i < limit; i++) {
      const d = buf[i] - buf[i + tau];
      sum += d * d;
    }
    yinBuffer[tau] = sum;
  }

  // cumulative mean normalized difference
  let cum = 0;
  yinBuffer[0] = 1;
  for (let tau = 1; tau <= maxTau; tau++) {
    cum += yinBuffer[tau];
    yinBuffer[tau] = yinBuffer[tau] * tau / cum;
  }

  // search for first minimum under threshold
  const threshold = 0.12; // empirical, adjustable
  let tauEstimate = -1;
  for (let tau = minTau; tau <= maxTau; tau++) {
    if (yinBuffer[tau] < threshold) {
      // find local minimum
      while (tau + 1 <= maxTau && yinBuffer[tau + 1] < yinBuffer[tau]) tau++;
      tauEstimate = tau;
      break;
    }
  }
  if (tauEstimate === -1) return null;

  // parabolic interpolation around tauEstimate
  const x0 = yinBuffer[tauEstimate - 1] || yinBuffer[tauEstimate];
  const x1 = yinBuffer[tauEstimate];
  const x2 = yinBuffer[tauEstimate + 1] || yinBuffer[tauEstimate];
  const betterTau = tauEstimate + (x2 - x0) / (2 * (2 * x1 - x2 - x0));
  const freq = sampleRate / betterTau;
  if (!isFinite(freq) || freq <= 0) return null;
  return freq;
}

/* ======================
   Autocorrelation fallback (fast)
   ====================== */
function autoCorrelate(buf, sampleRate) {
  const SIZE = buf.length;
  let rms = 0;
  for (let i = 0; i < SIZE; i++) { const v = buf[i]; rms += v*v; }
  rms = Math.sqrt(rms / SIZE);
  if (rms < parseFloat(sensRange.value)) return null;

  let r = new Float32Array(SIZE);
  for (let lag = 0; lag < SIZE; lag++) {
    let sum = 0;
    for (let i = 0; i < SIZE - lag; i++) sum += buf[i] * buf[i + lag];
    r[lag] = sum;
  }
  let peak = 1;
  for (let i = 2; i < SIZE; i++) if (r[i] > r[peak]) peak = i;
  // refine
  const left = r[peak - 1] || 0, center = r[peak], right = r[peak + 1] || 0;
  const shift = 0.5 * (left - right) / (left - 2*center + right);
  const trueLag = peak + shift;
  if (trueLag <= 0) return null;
  const freq = sampleRate / trueLag;
  if (!isFinite(freq) || freq <= 0) return null;
  return freq;
}

/* ======================
   FFT peak helper (parabolic interp)
   ====================== */
function peakFromFFT(freqData, sampleRate, fftSize) {
  // freqData in dB (Float32Array)
  let bestVal = -Infinity, bestIdx = -1;
  const binFreq = sampleRate / fftSize;
  const startBin = Math.max(2, Math.floor(50 / binFreq));
  const endBin = Math.min(freqData.length - 2, Math.ceil(1400 / binFreq));
  for (let i = startBin; i <= endBin; i++) {
    const v = freqData[i];
    if (v > bestVal) { bestVal = v; bestIdx = i; }
  }
  if (bestIdx < 1) return {freq:0, mag:0};
  // get neighbors in linear
  const vL = Math.pow(10, freqData[bestIdx-1]/20);
  const vC = Math.pow(10, freqData[bestIdx]/20);
  const vR = Math.pow(10, freqData[bestIdx+1]/20);
  const p = 0.5 * (vL - vR) / (vL - 2*vC + vR); // sub-bin shift
  const globalIndex = bestIdx + p;
  const freq = globalIndex * binFreq;
  const mag = Math.pow(10, bestVal/20);
  return {freq, mag};
}

/* ======================
   Combined detection: prefer YIN, fallback autocorr, confirm via FFT
   ====================== */
function detectPitchCombined(timeBuf, freqBuf, sampleRate) {
  // Attempt YIN
  const yinFreq = detectPitchYIN(timeBuf, sampleRate);
  if (yinFreq) return {freq: yinFreq, method: 'YIN'};

  // fallback autocorr
  const ac = autoCorrelate(timeBuf, sampleRate);
  if (ac) {
    // confirm with FFT
    const fftPeak = peakFromFFT(freqBuf, sampleRate, analyser.fftSize);
    if (fftPeak.freq && Math.abs(fftPeak.freq - ac) / ac < 0.08) {
      return {freq: (ac + fftPeak.freq)/2, method: 'AC+FFT'};
    }
    return {freq: ac, method: 'AC'};
  }

  // last resort: FFT only
  const fftOnly = peakFromFFT(freqBuf, sampleRate, analyser.fftSize);
  if (fftOnly.freq > 0) return {freq: fftOnly.freq, method: 'FFT'};

  return null;
}

/* ======================
   Drawing gauge
   ====================== */
function drawGauge(cents, tolerance, conf) {
  const W = canvas.width, H = canvas.height;
  ctx.clearRect(0,0,W,H);

  const cx = W/2, cy = H*1.15, r = Math.min(W*0.45, H*1.6);

  // arc
  ctx.lineWidth = 2; ctx.strokeStyle = "rgba(255,255,255,0.06)";
  ctx.beginPath(); ctx.arc(cx,cy,r,Math.PI*1.05,Math.PI*-0.05,false); ctx.stroke();

  // ticks
  ctx.strokeStyle = "rgba(255,255,255,0.06)";
  for (let c=-50;c<=50;c+=5){
    const ang = map(c,-50,50,Math.PI*1.05,Math.PI*-0.05);
    const x1 = cx + Math.cos(ang)*(r*0.92);
    const y1 = cy + Math.sin(ang)*(r*0.92);
    const x2 = cx + Math.cos(ang)*(r*0.98);
    const y2 = cy + Math.sin(ang)*(r*0.98);
    ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
  }

  // sweet spot small
  const small = Math.min(6, Math.max(1, parseInt(tolRange.value)));
  const leftAng = map(-small,-50,50,Math.PI*1.05,Math.PI*-0.05);
  const rightAng = map(small,-50,50,Math.PI*1.05,Math.PI*-0.05);
  ctx.beginPath(); ctx.fillStyle="rgba(0,208,132,0.22)";
  ctx.moveTo(cx,cy); ctx.arc(cx,cy,r*0.86,rightAng,leftAng,true); ctx.closePath(); ctx.fill();

  // needle
  const ang = map(cents,-50,50,Math.PI*1.05,Math.PI*-0.05);
  const nx = cx + Math.cos(ang)*(r*0.78);
  const ny = cy + Math.sin(ang)*(r*0.78);
  ctx.beginPath(); ctx.strokeStyle="rgba(0,0,0,0.45)"; ctx.lineWidth=6; ctx.moveTo(cx,cy); ctx.lineTo(nx,ny); ctx.stroke();
  ctx.beginPath(); ctx.strokeStyle=(Math.abs(cents)<=tolerance?"rgba(0,208,132,0.98)":"rgba(255,107,107,0.98)"); ctx.lineWidth=3; ctx.moveTo(cx,cy); ctx.lineTo(nx,ny); ctx.stroke();
  ctx.beginPath(); ctx.fillStyle="#cbd6dc"; ctx.arc(cx,cy,6,0,Math.PI*2); ctx.fill();

  // labels
  ctx.fillStyle="rgba(230,238,246,0.9)"; ctx.font="12px system-ui"; ctx.textAlign="left"; ctx.fillText("Grave",10,18); ctx.textAlign="right"; ctx.fillText("Agudo",W-10,18);

  // confidence bar
  const barW = 160, barH = 10; const bx = W - barW - 12, by = 12;
  ctx.fillStyle="rgba(255,255,255,0.06)"; ctx.fillRect(bx,by,barW,barH);
  ctx.fillStyle="rgba(0,208,132,0.9)"; ctx.fillRect(bx,by,barW*clamp(conf,0,1),barH);
  ctx.strokeStyle="rgba(255,255,255,0.08)"; ctx.strokeRect(bx,by,barW,barH);
  ctx.textAlign="center"; ctx.fillStyle="#bfead1"; ctx.font="11px system-ui"; ctx.fillText("Confianza",bx+barW/2,by+barH+11);
}

/* ======================
   Main loop: read analyser and detect
   ====================== */
function processAudioFrame(){
  if (!analyser) return;

  analyser.getFloatTimeDomainData(timeBuf);
  analyser.getFloatFrequencyData(freqBuf);

  const detection = detectPitchCombined(timeBuf, freqBuf, audioCtx.sampleRate);
  if (!detection) {
    statusEl.textContent = "Estado: sin pitch detectado";
    drawGauge(0, parseInt(tolRange.value), 0);
    requestAnimationFrame(processAudioFrame);
    return;
  }

  // smoothing: exponential + median history
  const rawFreq = detection.freq;
  lastSmoothed = lastSmoothed ? (smoothingAlpha * lastSmoothed + (1 - smoothingAlpha) * rawFreq) : rawFreq;

  // push history and compute median
  history.push(lastSmoothed);
  if (history.length > HISTORY_MAX) history.shift();
  const sorted = [...history].sort((a,b)=>a-b);
  const median = sorted[Math.floor(sorted.length/2)];

  // compute confidence:
  // frequency stability (std of history), and FFT magnitude confirmation
  const mean = history.reduce((a,b)=>a+b,0)/history.length;
  const variance = history.reduce((s,v)=>s+(v-mean)*(v-mean),0)/history.length;
  const stabScore = clamp(1 - Math.sqrt(variance)/15, 0, 1);

  // magnitude confirmation from FFT peak near median
  const fftPeak = peakFromFFT(freqBuf, audioCtx.sampleRate, analyser.fftSize);
  let magScore = clamp(fftPeak.mag * 1.5, 0, 1);

  let methodBonus = (detection.method === 'YIN') ? 0.15 : 0;
  const conf = clamp(0.5*stabScore + 0.35*magScore + methodBonus, 0, 1);

  // choose median as display freq
  const displayFreq = median;
  const noteObj = freqToNote(displayFreq);
  const noteName = noteObj.name;
  const exactFreq = noteObj.exactFreq;
  const cents = toCents(displayFreq, exactFreq);

  // string detection
  const stringName = closestString(displayFreq);

  // stability confirmation (require a few frames of stable readings)
  if (history.length >= Math.min(4, HISTORY_MAX)) {
    // measure small delta between latest and median
    const latest = history[history.length - 1];
    if (Math.abs(latest - median) < 2.5) stabilityCount++;
    else stabilityCount = 0;
  }

  // if sufficiently stable or high confidence, update UI
  const showNow = (stabilityCount >= 3) || (conf > 0.8);

  if (showNow) {
    noteNameEl.textContent = noteName;
    const base = noteName.replace(/[0-9]/g,'').replace('#','♯');
    noteLatinEl.textContent = (NOTAS_LATINAS[base.replace('♯','#')] || base) + '  —  ' + detection.method;
    centsEl.textContent = `${cents>=0?'+':''}${cents.toFixed(1)} c`;
    targetFreqEl.textContent = `${exactFreq.toFixed(2)} Hz`;
    stringDetectedEl.textContent = stringName;
    confidenceEl.textContent = `${Math.round(conf*100)}%`;
    statusEl.textContent = `Método: ${detection.method} · RMS umbral ${parseFloat(sensRange.value).toFixed(3)}`;
  } else {
    statusEl.textContent = `Buscando... método ${detection.method} · conf ${Math.round(conf*100)}%`;
  }

  drawGauge(clamp(cents,-50,50), parseInt(tolRange.value), conf);
  requestAnimationFrame(processAudioFrame);
}

/* ======================
   Start / Stop mic
   ====================== */
startBtn.addEventListener('click', async ()=>{
  try {
    // stop previous if any
    if (mediaStream){
      mediaStream.getTracks().forEach(t=>t.stop());
      mediaStream = null;
    }
    if (audioCtx){
      try { await audioCtx.close(); } catch(_) {}
      audioCtx = null;
    }

    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const stream = await navigator.mediaDevices.getUserMedia({ audio:true });
    mediaStream = stream;
    const src = audioCtx.createMediaStreamSource(stream);

    analyser = audioCtx.createAnalyser();
    analyser.fftSize = FFT_SIZE; // 4096
    timeBuf = new Float32Array(analyser.fftSize);
    freqBuf = new Float32Array(analyser.frequencyBinCount);

    src.connect(analyser);

    // reset
    history = [];
    lastSmoothed = 0;
    stabilityCount = 0;

    startBtn.disabled = true;
    stopBtn.disabled = false;

    requestAnimationFrame(processAudioFrame);
    statusEl.textContent = 'Estado: escuchando...';
  } catch (e) {
    console.error(e);
    alert('No se pudo acceder al micrófono. Revisa permisos.');
  }
});

stopBtn.addEventListener('click', async ()=>{
  if (mediaStream){
    mediaStream.getTracks().forEach(t=>t.stop());
    mediaStream = null;
  }
  if (audioCtx){
    try { await audioCtx.close(); } catch(_) {}
    audioCtx = null;
  }
  analyser = null;
  startBtn.disabled = false;
  stopBtn.disabled = true;
  statusEl.textContent = 'Estado: detenido';
  drawGauge(0, parseInt(tolRange.value), 0);
});

/* ======================
   Inicial draw
   ====================== */
drawGauge(0, parseInt(tolRange.value), 0);
</script>
</body>
</html>
